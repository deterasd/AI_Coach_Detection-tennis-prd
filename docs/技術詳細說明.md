# å½±ç‰‡è‡ªå‹•åˆ†å‰²å·¥å…· - è©³ç´°æŠ€è¡“èªªæ˜

## ğŸ¾ çƒé€²å…¥æ™‚æ©Ÿåˆ¤æ–·æ©Ÿåˆ¶

### 1. ç¶²çƒåµæ¸¬æµç¨‹
```python
def _detect_ball(self, frame):
    """åµæ¸¬ç•«é¢ä¸­çš„ç¶²çƒ"""
    results = self.tennis_model(frame, verbose=False)  # ä½¿ç”¨ YOLO æ¨¡å‹åµæ¸¬
    
    if not results[0].boxes:
        return False, 0, None
    
    best_box = max(results[0].boxes, key=lambda box: float(box.conf[0]))  # é¸æ“‡ä¿¡å¿ƒåº¦æœ€é«˜çš„æ¡†
    confidence = float(best_box.conf[0])
    
    if confidence < self.confidence_threshold.get():  # ä½æ–¼é–¾å€¼å‰‡å¿½ç•¥
        return False, confidence, None
    
    x1, y1, x2, y2 = best_box.xyxy[0].cpu().numpy()
    position = ((x1 + x2) / 2, (y1 + y2) / 2)  # è¨ˆç®—çƒçš„ä¸­å¿ƒé»ä½ç½®
    
    return True, confidence, position
```

### 2. é‚Šç·£å€åŸŸå®šç¾©
```python
# é‚Šç·£æª¢æ¸¬åƒæ•¸ (ç•«é¢é‚Šç·£15%çš„å€åŸŸè¦–ç‚ºé‚Šç·£)
edge_ratio = 0.15
edges = {
    'left': frame_width * 0.15,      # ç•«é¢å·¦é‚Š 15%
    'right': frame_width * 0.85,     # ç•«é¢å³é‚Š 15%
    'top': frame_height * 0.15,      # ç•«é¢ä¸Šæ–¹ 15%
    'bottom': frame_height * 0.85    # ç•«é¢ä¸‹æ–¹ 15%
}
```

### 3. çƒé€²å…¥åˆ¤æ–·é‚è¼¯
ç¨‹å¼ä½¿ç”¨å…©ç¨®æƒ…æ³ä¾†åˆ¤æ–·çƒé€²å…¥ç•«é¢ï¼š

#### æƒ…æ³Aï¼šçƒå¾ç„¡åˆ°æœ‰å‡ºç¾
```python
if current_detected and not prev_detected:
    return self._is_in_edge(current_pos, edges)  # çƒå¿…é ˆå‡ºç¾åœ¨é‚Šç·£å€åŸŸ
```
- **æ¢ä»¶**ï¼šå‰ä¸€å¹€æ²’åµæ¸¬åˆ°çƒï¼Œç•¶å‰å¹€åµæ¸¬åˆ°çƒ
- **åˆ¤æ–·**ï¼šçƒçš„ä½ç½®å¿…é ˆåœ¨ç•«é¢é‚Šç·£15%å€åŸŸå…§
- **åŸç†**ï¼šçƒå¾ç•«é¢å¤–é€²å…¥æ™‚ï¼Œé€šå¸¸æœƒå…ˆå‡ºç¾åœ¨é‚Šç·£

#### æƒ…æ³Bï¼šçƒå¾é‚Šç·£ç§»å‘ä¸­å¤®
```python
if current_detected and prev_detected and prev_pos and current_pos:
    prev_in_edge = self._is_in_edge(prev_pos, edges)
    curr_in_edge = self._is_in_edge(current_pos, edges)
    
    if prev_in_edge and not curr_in_edge:
        distance = ((current_pos[0] - prev_pos[0])**2 + (current_pos[1] - prev_pos[1])**2)**0.5
        return distance > 20  # ç§»å‹•è·é›¢å¿…é ˆå¤§æ–¼20åƒç´ 
```
- **æ¢ä»¶**ï¼šé€£çºŒå…©å¹€éƒ½åµæ¸¬åˆ°çƒ
- **åˆ¤æ–·**ï¼šçƒå¾é‚Šç·£å€åŸŸç§»å‹•åˆ°ä¸­å¤®å€åŸŸï¼Œä¸”ç§»å‹•è·é›¢>20åƒç´ 
- **åŸç†**ï¼šæ’é™¤éœæ­¢æˆ–å°å¹…éœ‡å‹•çš„çƒï¼Œç¢ºä¿æ˜¯çœŸæ­£çš„ç§»å‹•

### 4. æ™‚é–“é–“éš”æ§åˆ¶
```python
if current_time - last_entry_time >= self.min_interval.get():
    ball_entry_times.append(current_time)
    last_entry_time = current_time
```
- **ç›®çš„**ï¼šé¿å…åŒä¸€æ¬¡é€²å…¥è¢«é‡è¤‡è¨˜éŒ„
- **æ©Ÿåˆ¶**ï¼šå…©æ¬¡çƒé€²å…¥æ™‚é–“å¿…é ˆé–“éš”è‡³å°‘ `min_interval` ç§’ï¼ˆé è¨­2ç§’ï¼‰

---

## ğŸ”§ å½±ç‰‡åˆ†å‰²å·¥å…·

### 1. FFmpeg åˆ†å‰²ï¼ˆä¸»è¦æ–¹æ³•ï¼‰
```python
def _segment_with_ffmpeg(self, input_path, output_path, start_time, duration):
    cmd = ['ffmpeg', '-i', input_path, 
           '-ss', str(start_time),    # é–‹å§‹æ™‚é–“
           '-t', str(duration),       # ç‰‡æ®µé•·åº¦
           '-c', 'copy',             # ç›´æ¥è¤‡è£½ï¼Œä¸é‡æ–°ç·¨ç¢¼
           str(output_path), '-y']   # è¼¸å‡ºè·¯å¾‘ï¼Œè¦†è“‹ç¾æœ‰æª”æ¡ˆ
    result = subprocess.run(cmd, capture_output=True, timeout=60)
    return result.returncode == 0
```

**FFmpeg å„ªé»ï¼š**
- âœ… é€Ÿåº¦å¿«ï¼ˆç›´æ¥è¤‡è£½ä¸é‡æ–°ç·¨ç¢¼ï¼‰
- âœ… å“è³ªç„¡æå¤±
- âœ… æ”¯æ´å¤šç¨®æ ¼å¼
- âœ… ç²¾ç¢ºçš„æ™‚é–“å®šä½

### 2. OpenCV åˆ†å‰²ï¼ˆå‚™ç”¨æ–¹æ³•ï¼‰
```python
def _segment_with_opencv(self, input_path, output_path, start_time, duration):
    cap = cv2.VideoCapture(input_path)
    fps = cap.get(cv2.CAP_PROP_FPS)
    
    start_frame = int(start_time * fps)      # è½‰æ›ç‚ºå¹€æ•¸
    end_frame = int((start_time + duration) * fps)
    
    cap.set(cv2.CAP_PROP_POS_FRAMES, start_frame)  # å®šä½åˆ°é–‹å§‹å¹€
    out = cv2.VideoWriter(str(output_path), fourcc, fps, (width, height))
    
    for _ in range(end_frame - start_frame):
        ret, frame = cap.read()
        if not ret: break
        out.write(frame)  # é€å¹€å¯«å…¥
```

**OpenCV ç‰¹é»ï¼š**
- âš ï¸ é€Ÿåº¦è¼ƒæ…¢ï¼ˆéœ€é€å¹€è™•ç†ï¼‰
- âš ï¸ å¯èƒ½æœ‰å“è³ªæå¤±
- âœ… ç„¡éœ€é¡å¤–å®‰è£è»Ÿé«”
- âœ… è™•ç†ç©©å®š

### 3. å·¥å…·é¸æ“‡é‚è¼¯
```python
def _check_ffmpeg(self):
    try:
        subprocess.run(['ffmpeg', '-version'], capture_output=True, timeout=5)
        return True
    except:
        return False

# åœ¨åˆ†å‰²æ™‚æ±ºå®šä½¿ç”¨å“ªç¨®å·¥å…·
use_ffmpeg = self._check_ffmpeg()
method = "FFmpeg" if use_ffmpeg else "OpenCV"
```

---

## âš™ï¸ é—œéµåƒæ•¸è©³è§£

### 1. åµæ¸¬ä¿¡å¿ƒåº¦ (Confidence Threshold)
```python
self.confidence_threshold = tk.DoubleVar(value=0.5)  # é è¨­å€¼ï¼š0.5
```

**ä½œç”¨ï¼š**
- éæ¿¾ YOLO æ¨¡å‹çš„åµæ¸¬çµæœ
- åªæœ‰ä¿¡å¿ƒåº¦ â‰¥ è¨­å®šå€¼çš„åµæ¸¬æ‰è¢«æ¡ç”¨

**æ•¸å€¼æ„ç¾©ï¼š**
- `0.1`ï¼šå¾ˆå¯¬é¬†ï¼Œå¯èƒ½æœ‰å¾ˆå¤šèª¤åˆ¤
- `0.5`ï¼šå¹³è¡¡é»ï¼Œé©åˆå¤§å¤šæ•¸æƒ…æ³
- `0.9`ï¼šå¾ˆåš´æ ¼ï¼Œå¯èƒ½æ¼æ‰ä¸€äº›çœŸå¯¦çš„çƒ

**å¯¦éš›æ‡‰ç”¨ï¼š**
```python
if confidence < self.confidence_threshold.get():
    return False, confidence, None  # ä¿¡å¿ƒåº¦ä¸è¶³ï¼Œå¿½ç•¥æ­¤åµæ¸¬
```

### 2. é è¦½é–‹å§‹æ™‚é–“ (Preview Start Time)
```python
self.preview_start_time = tk.DoubleVar(value=-0.5)  # é è¨­å€¼ï¼š-0.5ç§’
```

**ä½œç”¨ï¼š**
- èª¿æ•´åˆ†å‰²ç‰‡æ®µçš„å¯¦éš›é–‹å§‹æ™‚é–“
- ç›¸å°æ–¼çƒé€²å…¥æ™‚é–“é»çš„åç§»

**æ•¸å€¼æ„ç¾©ï¼š**
- `è² å€¼`ï¼šåœ¨çƒé€²å…¥ä¹‹å‰é–‹å§‹éŒ„è£½
- `0`ï¼šå¾çƒé€²å…¥çš„ç¬é–“é–‹å§‹
- `æ­£å€¼`ï¼šåœ¨çƒé€²å…¥ä¹‹å¾Œæ‰é–‹å§‹

**è¨ˆç®—å…¬å¼ï¼š**
```python
start_time = max(0, entry_time + self.preview_start_time.get())
# ä¾‹å¦‚ï¼šçƒåœ¨ 10.0 ç§’é€²å…¥ï¼Œé è¦½é–‹å§‹æ™‚é–“ -0.5 ç§’
# å¯¦éš›é–‹å§‹æ™‚é–“ = max(0, 10.0 + (-0.5)) = 9.5 ç§’
```

**å¯¦ç”¨å»ºè­°ï¼š**
- `-0.5ç§’`ï¼šå¯ä»¥çœ‹åˆ°çƒé€²å…¥å‰çš„æº–å‚™å‹•ä½œ
- `-1.0ç§’`ï¼šæ›´å®Œæ•´çš„å‹•ä½œåºåˆ—
- `0ç§’`ï¼šå¾çƒé€²å…¥ç¬é–“é–‹å§‹ï¼Œç¯€çœç©ºé–“

### 3. æœ€å°é–“éš” (Minimum Interval)
```python
self.min_interval = tk.DoubleVar(value=2.0)  # é è¨­å€¼ï¼š2.0ç§’
```

**ä½œç”¨ï¼š**
- é˜²æ­¢åŒä¸€æ¬¡çƒé€²å…¥è¢«é‡è¤‡åµæ¸¬
- ç¢ºä¿ç‰‡æ®µä¹‹é–“æœ‰åˆç†é–“éš”

**å¯¦éš›æ‡‰ç”¨ï¼š**
```python
if current_time - last_entry_time >= self.min_interval.get():
    ball_entry_times.append(current_time)  # è¨˜éŒ„æ–°çš„é€²å…¥é»
```

---

## ğŸ“Š åˆ†å‰²æ¨¡å¼æ¯”è¼ƒ

### å›ºå®šé•·åº¦æ¨¡å¼
```python
duration = self.segment_duration.get()  # æ¯å€‹ç‰‡æ®µå›ºå®šé•·åº¦ï¼ˆå¦‚4ç§’ï¼‰
```
- **ç‰¹é»**ï¼šæ‰€æœ‰ç‰‡æ®µé•·åº¦ç›¸åŒ
- **é©ç”¨**ï¼šçµ±ä¸€çš„åˆ†æéœ€æ±‚
- **å„ªé»**ï¼šæª”æ¡ˆå¤§å°ä¸€è‡´ï¼Œä¾¿æ–¼æ‰¹æ¬¡è™•ç†

### å‹•æ…‹é•·åº¦æ¨¡å¼
```python
if i < len(self.ball_entry_times) - 1:
    end_time = self.ball_entry_times[i + 1] + self.preview_start_time.get()
else:
    end_time = entry_time + 4.0 + self.end_padding.get()
duration = max(1.0, end_time - start_time)
```
- **ç‰¹é»**ï¼šå¾ä¸€å€‹çƒé€²å…¥é»åˆ°ä¸‹ä¸€å€‹çƒé€²å…¥é»
- **é©ç”¨**ï¼šä¿æŒå‹•ä½œçš„å®Œæ•´æ€§
- **å„ªé»**ï¼šæ¯å€‹ç‰‡æ®µåŒ…å«å®Œæ•´çš„æ“Šçƒå‹•ä½œ

---

## ğŸ¯ åµæ¸¬æµç¨‹ç¸½çµ

1. **è¼‰å…¥ YOLO æ¨¡å‹** â†’ å°ˆé–€è¨“ç·´çš„ç¶²çƒåµæ¸¬æ¨¡å‹
2. **é€å¹€åˆ†æå½±ç‰‡** â†’ æ¯å¹€éƒ½é€²è¡Œçƒçš„åµæ¸¬
3. **ä¿¡å¿ƒåº¦éæ¿¾** â†’ åªä¿ç•™é«˜å¯ä¿¡åº¦çš„åµæ¸¬çµæœ
4. **ä½ç½®åˆ†æ** â†’ åˆ¤æ–·çƒæ˜¯å¦åœ¨é‚Šç·£å€åŸŸ
5. **é€²å…¥åˆ¤æ–·** â†’ æ ¹æ“šä½ç½®è®ŠåŒ–åˆ¤æ–·çƒé€²å…¥æ™‚æ©Ÿ
6. **æ™‚é–“è¨˜éŒ„** â†’ è¨˜éŒ„ç¬¦åˆæ¢ä»¶çš„é€²å…¥æ™‚é–“é»
7. **ç‰‡æ®µåˆ†å‰²** â†’ ä½¿ç”¨ FFmpeg/OpenCV åˆ†å‰²å½±ç‰‡
8. **æª”æ¡ˆæ•´ç†** â†’ è‡ªå‹•å‰µå»ºè³‡æ–™å¤¾ä¸¦åˆ†é¡å­˜æ”¾

é€™å€‹ç³»çµ±çµåˆäº†æ·±åº¦å­¸ç¿’ï¼ˆYOLOï¼‰ã€é›»è…¦è¦–è¦ºï¼ˆä½ç½®è¿½è¹¤ï¼‰å’Œå½±ç‰‡è™•ç†æŠ€è¡“ï¼Œèƒ½å¤ è‡ªå‹•ä¸”æº–ç¢ºåœ°è­˜åˆ¥ç¶²çƒé€²å…¥ç•«é¢çš„æ™‚æ©Ÿä¸¦é€²è¡Œæ™ºæ…§åˆ†å‰²ã€‚