# 3D 人物倒立問題完整技術分析報告

這份文件旨在深入解析 3D 重建過程中出現人物「倒立」現象的技術根源、數學原理，以及完整的解決方案。

---

## 1. 問題現象描述

在將 2D 影像中的關鍵點轉換為 3D 空間座標後，於 Three.js 或其他 3D 檢視器中觀察時，發現：
*   人物呈現**頭下腳上**的倒立姿態。
*   人物的動作與相對位置是正確的（例如舉右手，模型也是舉右手），僅是整體上下顛倒。
*   數據診斷顯示：**腳踝的 Y 座標值 > 鼻子的 Y 座標值**。

---

## 2. 核心原因：座標系定義的衝突

這個問題並非拍攝失誤，而是兩個領域對「座標系」定義不同所導致的必然結果。

### 2.1 相機與電腦視覺的座標系 (Computer Vision Convention)
在 OpenCV 與大多數電腦視覺演算法中，座標系是這樣定義的：
*   **原點 (Origin)**：相機的光心 (鏡頭中心)。
*   **X 軸**：水平向右。
*   **Y 軸**：**垂直向下**。
    *   這是為了對應影像像素座標 (Pixel Coordinate)。影像的 (0,0) 在左上角，往下掃描時行數 (Row) 增加，所以 Y 軸必須向下。
*   **Z 軸**：光軸指向前方。

### 2.2 3D 圖學的座標系 (Computer Graphics Convention)
在 Three.js、OpenGL、Unity 等 3D 引擎中，座標系通常符合人類對物理世界的直覺：
*   **原點 (Origin)**：世界中心 (通常在地面)。
*   **Y 軸**：**垂直向上** (代表高度/海拔)。
    *   這是為了模擬重力方向 (重力向下，所以高度向上為正)。

### 2.3 衝突發生點
當您進行 3D 重建時，如果沒有特別指定「世界座標系」在哪裡，演算法通常會預設**「以第一台相機 (Camera 1) 為世界中心」**。

這意味著：
1.  世界的 Y 軸 = 相機的 Y 軸 = **向下**。
2.  **腳**在畫面下方 $\rightarrow$ 像素 Y 值大 $\rightarrow$ 3D 空間 Y 值大 (正數)。
3.  **頭**在畫面上方 $\rightarrow$ 像素 Y 值小 $\rightarrow$ 3D 空間 Y 值小 (負數或較小正數)。
4.  當這組數據進入 Three.js (Y 軸向上) 時：
    *   Y 值大的腳被畫在**上面**。
    *   Y 值小的頭被畫在**下面**。
    *   **結果：倒立。**

---

## 3. 數學原理深度解析

### 3.1 投影矩陣 P 的構成
一個投影矩陣 $P$ 由內參 $K$ 和外參 $[R|t]$ 組成：
$$P = K \times [R | t]$$
*   $K$：相機內參 (焦距、光心)。
*   $R$：旋轉矩陣 (描述世界座標系如何轉到相機座標系)。
*   $t$：平移向量 (描述世界原點到相機的距離)。

### 3.2 您的矩陣設定 (P1 = [K|0])
您目前的 $P1$ 矩陣形式為：
$$P1 = \begin{bmatrix} f_x & 0 & c_x & 0 \\ 0 & f_y & c_y & 0 \\ 0 & 0 & 1 & 0 \end{bmatrix}$$
這代表 $R$ 是單位矩陣 (Identity Matrix)，$t$ 是零向量。
**物理意義**：您直接宣告「側面相機的位置就是世界的原點，側面相機的角度就是世界的角度」。因此，世界繼承了相機「Y 軸向下」的特性。

---

## 4. 為什麼之前的嘗試是成功的？

如果您之前的拍攝流程看似相同，但結果正確，通常是因為以下兩個隱性因素之一：

### 因素 A：使用了「棋盤格定義地面」的標定法
在標準的立體標定 (Stereo Calibration) 流程中，如果您將棋盤格平放在地面，並將棋盤格的角點定義為世界座標 (例如 $Z=0$)：
*   演算法會計算出一個旋轉矩陣 $R$，這個 $R$ 會包含一個約 180 度的旋轉 (或座標軸變換)。
*   它將相機的「Y-Down」視角轉換為棋盤格的「Z-Up」或「Y-Up」視角。
*   **這次的差異**：您可能直接使用了相機相對位姿，而沒有強制對齊地平面。

### 因素 B：程式碼中的隱藏修正
許多開源專案 (如基於 MediaPipe 的範例) 為了讓初學者容易上手，會在後處理階段加入「翻轉」程式碼：
```python
# 常見的隱藏修正
y_3d = -y_3d  # 直接翻轉
# 或者
y_3d = image_height - y_2d  # 在 2D 階段就翻轉
```
這次的程式碼可能更為「純粹」，直接輸出了數學運算的原始結果。

---

## 5. 解決方案 (Step-by-Step)

### 方案 A：矩陣修正法 (最快速，推薦目前使用)
我們不需要重新拍攝，只需在數學上「欺騙」系統，告訴它 Y 軸是反的。

**操作步驟**：
1.  找到定義 `P1` 和 `P2` 的程式碼。
2.  將矩陣的 **第二行 (Column 1)** 的所有數值乘以 **-1**。

**原理**：
矩陣乘法中，第二行對應輸入向量 $(X, Y, Z, 1)$ 中的 $Y$ 分量。將係數變號，等同於輸入的 $Y$ 變號。

**程式碼範例**：
```python
# 原始 P1
P1 = np.array([
    [561.93,   0.00, 634.63, 0.00],
    [  0.00, 563.92, 357.49, 0.00],
    [  0.00,   0.00,   1.00, 0.00]
])

# 修正後的 P1 (注意第二行變號)
P1_fixed = np.array([
    [561.93,   -0.00, 634.63, 0.00],
    [  0.00, -563.92, 357.49, 0.00],  # 563.92 -> -563.92
    [  0.00,   -0.00,   1.00, 0.00]
])
```

### 方案 B：標定修正法 (最標準，物理層面)
如果您希望從源頭建立一個完美的座標系 (例如：原點在發球線中心，Y 軸垂直向上)。

**操作步驟**：
1.  **佈置場地**：在場地中心地面平放棋盤格 (Checkerboard)。
2.  **定義世界點**：設定棋盤格角點的世界座標。例如，左上角為 $(0,0,0)$，向右為 $+X$，向前為 $+Z$ (地面)，垂直向上為 $+Y$。
3.  **計算位姿 (SolvePnP)**：
    *   使用 `cv2.solvePnP` 計算相機相對於這些世界點的 $R$ 和 $t$。
    *   這樣算出的 $P = K[R|t]$ 就會自動包含將「相機座標」轉為「地面座標」的變換。

---

## 6. 總結

*   **現象**：人物倒立是因為 **相機座標系 (Y-Down)** 與 **3D 繪圖座標系 (Y-Up)** 的定義相反。
*   **性質**：這是數學定義問題，非操作失誤。
*   **解法**：
    *   **短期**：修改投影矩陣的第二行符號 (Flip Y)。
    *   **長期**：在標定階段引入地面控制點 (Ground Control Points)，強制定義世界座標系。
